function L = ReadCIMGuidePoints(cim_folder,mfolder,varargin)
% This function reads guide points from a CIM folder and update the LVMotionModel object L.
%
%   L = ReadCIMGuidePoints(cim_folder,model_name);
%   L = ReadCIMGuidePoints(...,args);
%
% Optional arguments:
%   - 'slice_offset', integer. Default is 1.
%     Offset to start slice from.
%   - 'phase_offset', integer. Default is 0.
%     Offset to start phase from.
%
% Author: Avan Suinesiaputra - Centre for Advanced Imaging, Univ. of Auckland (2012)

L = [];
if( ~exist(cim_folder,'dir') )
    return;
end

% THIS IS FROM CIM's GuidePoint.h
GP_NAMES = {...
  'GP_APEX_CENTRAL_AXIS', 0;...
  'GP_BASE_CENTRAL_AXIS', 1;...
  'GP_RV_INSERTION', 2;...
  'GP_BASE_PLANE', 3;...
  'GP_INTERPOLATED_BASEPOINT', 4;...
  'GP_LV_ENDO', 5;...
  'GP_LV_EPI', 6;...
  'GP_LV_ENDO_CONSTRAINED', 7;...
  'GP_LV_EPI_CONSTRAINED', 8;...
  'GP_LV_ENDO_IMAGE', 9;...
  'GP_LV_EPI_IMAGE', 10;...
  'GP_GEOM_PARAM', 11;...
  'GP_CENTROID', 12;...
  'GP_MYO2D', 13;...
  'GP_MYO1D', 14;... 
  'GP_LV_BASE_ENDO', 15;...
  'GP_LV_BASE_EPI', 16;...
  'GP_MYOIMAGE1D', 17;...
  'GP_RVFW_ENDO', 18;...
  'GP_RVS_ENDO', 19;...
  'GP_EPI', 20;... 
  'GP_VALVE_MITRAL', 21;...
  'GP_VALVE_AORTIC', 22;...
  'GP_VALVE_TRICUSPID', 23;...
  'GP_VALVE_PULMONARY', 24;...
  'GP_RV_CENTROID', 25;...
  'GP_RVFW_ENDO_IMAGE', 26;...
  'GP_RVS_ENDO_IMAGE', 27;...
  'GP_EPI_IMAGE', 28;...
  'GP_ROI', 29
  'GP_MITRAL_CENTROID'   30;... %ADDED KG 20130204 for reading LV FITS from RVLV model
  'GP_AORTIC_CENTROID'   31;...
  'GP_TRICUSPID_CENTROID' 32;...
  'GP_PULMONARY_CENTROID' 33;...
  'GP_LV_EPI_APEX'        34;...
  'GP_LV_EPI_WARP_CONTOUR'     35;... 
  'GP_LV_ENDO_WARP_CONTOUR'    36;...
  'GP_RVFW_ENDO_WARP_CONTOUR'  37;...  
  'GP_RVS_ENDO_WARP_CONTOUR'   38;...
  'GP_EPI_WARP_CONTOUR'        39;... 
  'GP_VALVE_MITRAL_WARP_CONTOUR'   40;...
  'GP_VALVE_AORTIC_WARP_CONTOUR'   41;...
  'GP_VALVE_TRICUSPID_WARP_CONTOUR' 42;...
  'GP_VALVE_PULMONARY_WARP_CONTOUR' 43;...
  'GP_RV_INSERTION_WARP'  44;...
  'GP_VALVE_MITRAL_WARP'  45;...
  'GP_VALVE_AORTIC_WARP'  46;...
  'GP_VALVE_TRICUSPID_WARP'   47;...
  'GP_VALVE_PULMONARY_WARP'   48;...
  'GP_LV_EPI_APEX_WARP'  49;...
  'PP_VALVE_MITRAL'      50;...
  'PP_VALVE_AORTIC'      51;...
  'PP_VALVE_TRICUSPID'   52;...
  'PP_VALVE_PULMONARY'   53;...
  'PP_LV_ENDO'     54;...
  'PP_RVFW_ENDO'   55;...
  'PP_RVS_ENDO'   56;...
  'PP_EPI'        57};

% default options
opt.slice_offset = 1;
opt.phase_offset = 0;

% get optional arguments
for i=1:2:numel(varargin)
    if( isfield(opt,varargin{i}) ), opt.(varargin{i}) = varargin{i+1};
    else error('Unknown option %s',varargin{i}); end
end

cim_gid_file = sprintf('%s%s%s%sguide_points.data',cim_folder,filesep,mfolder,filesep);
if( ~exist(cim_gid_file,'file') )
    return;
end

% read guide points
fid = fopen(cim_gid_file,'r+');
if( fid<3 )
    fprintf(2,'Error opening file %s.\n',cim_gid_file);
    return;
end

% find: 'number of points: <number>' line
npoints = 0;
while npoints<1
    ln = fgetl(fid);
    if( ~ischar(ln) ), break; end
    
    npoints = regexp(ln,'\s*number of points\s*:\s*(\d+)','tokens','once');
    if( ~isempty(npoints) ), npoints = str2num(npoints{1}); end
end

if( npoints<1 )
    fclose(fid);
    fprintf(2,'This is not a valid guide points file.\n');
    return;
end

% the guide point format:
% 1 2 3  4      5            6               7             8
% X Y Z TYPE WEIGHT SERIES(0=SAX,1=LAX) SLICE(from_0) PHASE(from_0)
GP = textscan(fid,' %f %f %f %f %f %f %f %f  %*[^\n]',npoints);

% slice & phase offset
GP{7} = GP{7} + opt.slice_offset;
GP{8} = GP{8} + opt.phase_offset;

% don't forget to close it
fclose(fid);

% sort them into series_0 & series_1

% SAX
gp_idx = unique(GP{4}(GP{6}==0));  
for gpi=1:numel(gp_idx)
    idx = find(GP{4}==gp_idx(gpi) & GP{6}==0);
    gname = GP_NAMES{cell2mat(GP_NAMES(:,2))==gp_idx(gpi),1};
    series_0.(gname) = [GP{1}(idx) GP{2}(idx) GP{3}(idx) GP{7}(idx) GP{8}(idx)];
end

% LAX
gp_idx = unique(GP{4}(GP{6}==1));  
for gpi=1:numel(gp_idx)
    idx = find(GP{4}==gp_idx(gpi) & GP{6}==1);
    gname = GP_NAMES{cell2mat(GP_NAMES(:,2))==gp_idx(gpi),1};
    series_1.(gname) = [GP{1}(idx) GP{2}(idx) GP{3}(idx) GP{7}(idx) GP{8}(idx)];
end

% update L
L.colnames = {'X','Y','Z','slice','phase'};
L.series_0 = series_0;
L.series_1 = series_1;